\section{Crear aplicaciones}

Uno de los objetivos de QGIS es proporcionar no sólo una aplicación, sino un conjunto de
bibliotecas que se puedan usar para crear nuevas aplicaciones. Este objetivo se ha realizado
con la reconstrucción de bibliotecas que tuvo lugar después del lanzamiento de la versión 0.8.
Con el lanzamiento de la 0.9 es posible el desarrollo de aplicaciones independientes que usen
bien C++ o Python.

En este capítulo echaremos una breve ojeada al proceso de crear aplicaciones independientes en
Python. El blog de QGIS tiene varios ejemplos de creación de aplicaciones en
PyQGIS\footnote{An application created using Python and the QGIS bindings}. Usaremos uno de
ellos como punto de partida para tener una idea de cómo crear una aplicación.

Las funciones que queremos en la aplicación son:

\begin{itemize}
\item Cargar una capa vectorial.
\item Panorámica.
\item Acercar y alejar zum.
\item Zum a la extesión completa de la capa.
\item Estalecer colores personalizados al cargar la capa.
\end{itemize} 

Se trata de un conjunto mínimo de funciones. Comencemos por diseñar la GUI usando Qt Designer.

\subsection{Diseñar la GUI}

Puesto que estamos creando una aplicación mínima, usaremos la misma aproximación con la GUI. 
Usando Qt Designer, creamos una MainWindow sencilla sin menús ni barras de herramientas. 
Esto nos da un slate en blando con el que trabajar. Para crear la MainWindow:

\begin{enumerate}
\item Crear un directorio para desarrollar la aplicación y cambiar a él.
\item Ejecutar Qt Designer.
\item Deba aparecer el diálogo "Formulario nuevo". Si no lo hace, seleccionar 
\textsl{Formulario nuevo...} del menú \textsl{Archivo}.
\item Seleccionar "Ventana principal" de la lista de plantillas/formularios.
\item Pulsar \textsl{Crear}.
\item Redimensionar la nueva ventana a algo manejable.
\item Buscar el widget Marco (Frame) en la lista (bajo Contenedores) y arrastrarlo a la ventana principal
que acabamos de crear.
\item Pulsar fuera del marco para seleccionar el área de la ventana principal.
\item Pulsar en la herramienta \textsl{Lay Out in a Grid}. Al hacerlo el marco se expandirá hasta
ocupar totalmente la ventana principal.
\item Guardar el formulario como \textsl{mainwindow.ui}.
\item Salir de Qt Designer.
\end{enumerate} 

Ahora compile el formulario usando el compilador de la interfaz de PyQt:

\begin{verbatim}
   pyuic4 -o mainwindow_ui.py mainwindow.ui
\end{verbatim}

Esto crea la fuente de Python para la ventana principal de la GUI. Lo siguiente que necesitamos es crear
el código de la aplicación para rellenar la slate en blanco con algunas herramientas que podamos usar.

\subsection{Crear la VentanaPrincipal}

Ahora estamos listos para escribir la clase \textbf{MainWindow} que hará el trabajo real. Puesto que
Since it takes up quite a few lines, we'll look at it in chunks, comenzaremos con la sección de
importación y la configuración del entorno:

\begin{verbatim}
1 # Loosely based on:
2 #   C++ Tutorial 2 oribignal por Tim Sutton
3 #   migrado a Python por Martin Dobias
4 #   con mejoras por Gary Sherman para FOSS4G2007
5 # Licenciado bajo los términos de la GNU GPL 2
6
7 from PyQt4.QtCore import *
8 from PyQt4.QtGui import *
9 from qgis.core import *
10 from qgis.gui import *
11 import sys
12 import os
13 # Importar nuestra GUI
14 from mainwindow_ui import Ui_MainWindow
15 # Importar nuestros recursos (iconos)
16 import resources
17 
18 # La variable de entorno QGISHOME se debe establecer al directorio de instalación de la versión 0.9
19 # antes de ejecutar esta aplicación
20 qgis_prefix = os.getenv("QGISHOME")
\end{verbatim}

Parte de esto debería resultar familiar de nuestro complemento, especialmente las importaciones de PyQt4 y
QGIS. Algunas cosas específicas que destacar son la importacion de nuestra GUI en la línea 14 y la
importación de nuestro archivo de recursos en la línea 16.

Nuestra aplicación necesita saber dóndo encontrar la instalación de QGIS. Por eso, establecemos la
variable de entorno QGISHOME para que apunto al directorio de instalación de QGIS 0.9. En la línea
20 guardamos este valor del entorno para usarla después.

Lo siguiente que necesitamos es crear nuestra clase \textbf{MainWindow} que contendrá toda la lógica de
nuestra aplicación.
\begin{verbatim}
21 class MainWindow(QMainWindow, Ui_MainWindow):
22 
23   def __init__(self):
24     QMainWindow.__init__(self)
25 
26     # Requerido por Qt4 para inicializar la UI
27     self.setupUi(self)
28 
29     # Establecer el título de la aplicación
30     self.setWindowTitle("FOSS4G2007 Demo App")
31 
32     # Crear el lienzo del mapa
33     self.canvas = QgsMapCanvas()
34     # Establecer el color de fondo a azul claro
35     self.canvas.setCanvasColor(QColor(200,200,255))
36     self.canvas.enableAntiAliasing(True)
37     self.canvas.useQImageToRender(False)
38     self.canvas.show()
39 
40     # Disponer nuestros widgets en la ventana principal usando una 
41     # vertical box layout
42     self.layout = QVBoxLayout(self.frame)
43     self.layout.addWidget(self.canvas)
44 
45     # Crear las acciones para nuestras herramientas y conectar cada una con el método
46     # adecuado
47     self.actionAddLayer = QAction(QIcon(":/foss4g2007/mActionAddLayer.png"),
48     \
49         "Add Layer", self.frame)
50     self.connect(self.actionAddLayer, SIGNAL("activated()"), self.addLayer)
51     self.actionZoomIn = QAction(QIcon(":/foss4g2007/mActionZoomIn.png"), \
52         "Zoom In", self.frame)
53     self.connect(self.actionZoomIn, SIGNAL("activated()"), self.zoomIn)
54     self.actionZoomOut = QAction(QIcon(":/foss4g2007/mActionZoomOut.png"), \
55         "Zoom Out", self.frame)
56     self.connect(self.actionZoomOut, SIGNAL("activated()"), self.zoomOut)
57     self.actionPan = QAction(QIcon(":/foss4g2007/mActionPan.png"), \
58         "Pan", self.frame)
59     self.connect(self.actionPan, SIGNAL("activated()"), self.pan)
60     self.actionZoomFull = QAction(QIcon(":/foss4g2007/mActionZoomFullExtent.png"), \
61         "Zoom Full Extent", self.frame)
62     self.connect(self.actionZoomFull, SIGNAL("activated()"),
63     self.zoomFull)
64 
65     # Crear una barra de herramientas
66     self.toolbar = self.addToolBar("Map")
67     # Add the actions to the toolbar
68     self.toolbar.addAction(self.actionAddLayer)
69     self.toolbar.addAction(self.actionZoomIn)
70     self.toolbar.addAction(self.actionZoomOut);
71     self.toolbar.addAction(self.actionPan);
72     self.toolbar.addAction(self.actionZoomFull);
73 
74     # Crear las herramientas de mapa
75     self.toolPan = QgsMapToolPan(self.canvas)
76     self.toolZoomIn = QgsMapToolZoom(self.canvas, False) # false = in
77     self.toolZoomOut = QgsMapToolZoom(self.canvas, True) # true = out
\end{verbatim}

Las líneas 21 a 27 son la declaración básica y la inicialización de la \textbf{MainWindow}
y la configuración de la interfaz de usuario usando el método \textsl{setupUi}. Esto hace
falta para todas las aplicaciones.

Next we set the title for the application so it says something more
interesting than 'MainWindow' (line 30). Once that is
complete, we are ready to complete the user interface. When we created it in
Designer, we left it very sparse---just a main window and a frame. You could
have added a menu and the toolbar using Designer, however we'll do it with
Python.

In lines 33 through 38 we set up the map
canvas, set the background color to a light blue, and enable antialiasing.
We also tell it not to use a QImage for rendering (trust me on this one) and
then set the canvas to visible by calling the \textsl{show} method.

Next we set the layer to use a vertical box layout within the frame and add the map
canvas to it in line 43.

Lines 48 to 63 set up the actions and connections for the tools in our 
toolbar. For each tool, we create a
\textbf{QAction} using the icon we defined in our resources file. Then we
connect up the \textsl{activated} signal from the tool to the method in our
class that will handle the action. This is similar to how we set things up
in the plugin example.

Once we have the actions and connections, we need to add them to the
toolbar. In lines 66 through 72 we create the
toolbar and add each tool to it.

Lastly we create the three map tools for the application (lines
75 through 77). We'll use the map tools in a
moment when we define the methods to make our application functional. Let's
look at the methods for the map tools.

\begin{verbatim}
78   # Set the map tool to zoom in
79   def zoomIn(self):
80     self.canvas.setMapTool(self.toolZoomIn)
81 
82   # Set the map tool to zoom out
83   def zoomOut(self):
84     self.canvas.setMapTool(self.toolZoomOut)
85 
86   # Set the map tool to 
87   def pan(self):
88    self.canvas.setMapTool(self.toolPan)
89 
90   # Zoom to full extent of layer
91   def zoomFull(self):
92     self.canvas.zoomFullExtent()
\end{verbatim}

For each map tool, we need a method that corresponds to the connection we
made for each action. In lines 79 through 88 we set up a method for each 
of the three tools that
interact with the map. When a tool is activated by clicking on it in the
toolbar, the corresponding method is called that ``tells'' the map canvas it
is the active tool. The active tool governs what happens when the mouse is
clicked on the canvas.

The zoom to full extent tool isn't a map tool---it does its job without
requiring a click on the map. When it is activated, we call the
\textsl{zoomFullExtent} method of the map canvas (line 92).
This completes the implementation of all our tools except one---the add
layer tool. Let's look at it next:

\begin{verbatim}
93   # Add an OGR layer to the map
94   def addLayer(self):
95     file = QFileDialog.getOpenFileName(self, "Open Shapefile", ".", "Shapefiles
96     (*.shp)")
97     fileInfo = QFileInfo(file)
98 
99     # Add the layer
100     layer = QgsVectorLayer(file, fileInfo.fileName(), "ogr")
101
102    if not layer.isValid():
103      return
104
105    # Change the color of the layer to gray
106    symbols = layer.renderer().symbols()
107    symbol = symbols[0]
108    symbol.setFillColor(QColor.fromRgb(192,192,192))
109
110    # Add layer to the registry
111    QgsMapLayerRegistry.instance().addMapLayer(layer);
112
113    # Set extent to the extent of our layer
114    self.canvas.setExtent(layer.extent())
115
116    # Set up the map canvas layer set
117    cl = QgsMapCanvasLayer(layer)
118    layers = [cl]
119    self.canvas.setLayerSet(layers)
\end{verbatim}

In the \textsl{addLayer} method we use a \textbf{QFileDialog} to get the
name of the shapefile to load. This is done in line 96.
Notice that we specify a ``filter'' so the dialog will only show files of
type \textsl{.shp}.

Next in line 97 we create a \textbf{QFileInfo} object from the shapefile path. Now the layer is
ready to be created in line 100. Using the \textbf{QFileInfo} object to get the file name
from the path we specify it for the name of the layer when it is created. To make sure that the layer is valid and won't
cause any problems when loading, we check it in line 102. If it's bad, we bail out and don't add it to
the map canvas.

Normally layers are added with a random color. Here we want to tweak the colors for the layer to make a more pleasing
display. Plus we know we are going to add the \textsl{world\_borders} layer to the map and this will make it look nice
on our blue background. To change the color, we need to get the symbol used for rendering and use it to set a new fill color. This is done in lines
106 through 108. 

All that's left is to actually add the layer to the registry and a few other housekeeping items (lines
111 through 119). This stuff is standard for adding a layer and the
end result is the world borders on a light blue background. The only thing you may not want to do is set the extent to
the layer, if you are going to be adding more than one layer in your application.

That's the heart of the application and completes the \textbf{MainWindow} class. 

\subsection{Finishing Up}

The remainder of the code shown below 
creates the \textbf{QgsApplication} object, sets the path to the QGIS install, sets
up the \textsl{main} method and then starts the application. The only other thing to note is that we move the
application window to the upper left of the display. We could get fancy and use the Qt API to center it on the screen.

\begin{verbatim}
120 def main(argv):
121   # create Qt application
122   app = QApplication(argv)
123 
124   # Initialize qgis libraries
125   QgsApplication.setPrefixPath(qgis_prefix, True)
126   QgsApplication.initQgis()
127 
128   # create main window
129   wnd = MainWindow()
130   # Move the app window to upper left
131   wnd.move(100,100)
132   wnd.show()
133 
134   # run!
135   retval = app.exec_()
136   
137   # exit
138   QgsApplication.exitQgis()
139   sys.exit(retval)
140 
141 
142 if __name__ == "__main__":
143   main(sys.argv)
\end{verbatim}

\subsection{Running the Application}

Now we can run the application and see what happens. Of course if you are like most developers, you've been testing it
out as you went along. 

Before we can run the application, we need to set some environment variables. On Linux or OS X:

\begin{verbatim}
export LD_LIBRARY_PATH=$HOME/qgis_09/lib
export PYTHONPATH=$HOME/qgis_09/share/qgis/python
export QGISHOME=$HOME/qgis_09
\end{verbatim}

For Windows:
\begin{verbatim}
set PATH=C:\qgis;%PATH%
set PYTHONPATH=C:\qgis\python
set QGISHOME=C:\qgis
\end{verbatim}

In the case of Linux or OS X, we assume that QGIS is installed in your home directory in 
\textsl{qgis\_09}. For Windows, QGIS is installed in \textsl{C:\textbackslash qgis}.

When the application starts up, it looks like this:

\begin{figure}[ht]
\begin{center}
  \caption{Starting the new demo application}\label{fig:demo_app_startup}\smallskip
  \includegraphics[scale=0.8]{getdsn}
\end{center}
\end{figure}

To add the \textsl{world\_borders} layer, click on the \textsl{Add Layer} tool and navigate to the data directory.
Select the shapefile and click \textsl{Open} to add it to the map. Our custom fill color is applied and the result is:

\begin{figure}[ht]
\begin{center}
  \caption{Adding a layer the demo application}\label{fig:demo_app_done}\smallskip
  \includegraphics[scale=0.8]{getdsn}
\end{center}
\end{figure}

Creating a PyQGIS application is really pretty simple. In less than 150 lines of code we have an application that can
load a shapefile and navigate the map. If you play around with the map, you'll notice that some of the built-in features
of the canvas also work, including mouse wheel scrolling and panning by holding down the \textsl{Space} bar and
moving the mouse.

Some sophisticated applications have been created with PyQGIS and more are in the works. This is pretty impressive,
considering that this development has taken place even before the official release of QGIS 0.9.

\begin{Tip}\caption{\textsc{Documentation For PyQGIS}}
\qgistip{Whether you are writing a plugin or a PyQGIS application, you are going to
need to refer to both the QGIS API documentation (\url{http://qgis.org}) and
the PyQt Python Bindings Reference Guide
(\url{http://www.riverbankcomputing.com/Docs/PyQt4/pyqt4ref.html}). These
documents provide information about the classes and methods you'll
use to bring your Python creation to life.
}
\end{Tip} 
