% vim: set textwidth=78 autoindent:

\section{Creare applicazioni PyQGIS}

% when the revision of a section has been finalized, 
% comment out the following line:
% \updatedisclaimer

Uno degli obiettivi di QGIS è fornire non soltanto un'applicazione ma anche un set di librerie che possano essere usate per creare nuove applicazioni. Questo obiettivo è stato realizzato mediante la ristrutturazione delle libreria che ha avuto luogo dopo il rilascio della versione 0.8. Dal rilascio dell aversione 0.9, è possibile lo sviluppo di applicazioni indipendenti usando C++ o Python. Si raccomanda di usare QGIS 1.0.0 o superiore come base per le proprie applicazioni python poichè da questa versione si fornisce un API stabile e coerente.

In questo capitolo si darà un'occhiata al processo di creazione di un'applicazione Python indipendente. Il blog di QGIS ha vari esempi su come creare applicazioni PyQGIS\footnote{Un'applicazione creata usando Python ed i legami QGIS}. Useremo una di esse come punto di partenza per un'occhiata a come creare un'applicazione.

Le funzioni che vogliamo nell'applicazione sono:

\begin{itemize}
\item Caricare un layer vettoriale
\item Panoramica
\item Ingrandimento e riduzione
\item Ingrandiamento alla completa estensione del layer
\item Impostazione di colori personlaizzati al caricamento del layer
\end{itemize} 

Questo è un set di funzioni piuttosto minimo. Cominciamo progettando il GUI usando Qt Designer.

\subsection{Progettare il GUI}

Dato che stiamo creando un'applicazione minimale, useremo lo stesso approccio per il GUI. Usando Qt Designer, si crea una semplice finestra principale (MainWindow) priva di menu e barre degli strumenti. Questo ci da una lavagna bianca per lavorare. Per creare la finestra principale:

\begin{enumerate}
\item Creare una directory per sviluppare l'applicazione andare in essa
\item Lanciare Qt Designer
\item Dovrebbe apparire la finestra di dialogo \qtdialog{New form}. Se non appare, scegliere
\qtdropmenuopt{New form...} dal menu \qtmainmenuopt{File}.
\item Scegliere \qtdropmenuopt{Main Window} dalla lista 
the \qtdropmenuopt{templates/forms} 
\item Premere \qtdropmenuopt{Create} 
\item Ridimensionare la nuova finestra ad una dimensione maneggevole
\item Trovare nella lista il widget \qtdropmenuopt{Frame} 
(sotto \qtdropmenuopt{Containers}) e trascinarlo nella finestra principale appena creata
\item Premere all'esterno della cornice per selezionare l'area della finestra principale 
\item Premere lo strumento \qtdropmenuopt{Lay Out in a Grid}. Quando si fa questo, ila cornice si allarga a riempire l'intera finestra principale
\item Salvare il modulo come \usertext{mainwindow.ui} 
\item \qtdropmenuopt{Exit} Qt Designer
\end{enumerate} 

Ora compilare il modulo usando l'interfaccia compilatore PyQt:

\begin{verbatim}
   pyuic4 -o mainwindow_ui.py mainwindow.ui
\end{verbatim}

Questo crea la sorgente Python per la finestra principale GUI. Poi si deve creare il codice dell'applicazione per riempire la lavagna bianca con alcuni strumenti che si possono usare.

\subsection{Creare la Finestra Principale}

Adesso siamo pronti a scrivere la classe \classname{MainWindow} che farà il vero lavoro.
Dato che ci vogliono parecchie linee, ci daremo un'occhiata a pezzi, cominciando con la sezione importazione e il settaggio dell'ambiente:

\begin{verbatim}
1 # Loosely based on:
2 #   Original C++ Tutorial 2 by Tim Sutton
3 #   ported to Python by Martin Dobias
4 #   with enhancements by Gary Sherman for FOSS4G2007
5 # Licensed under the terms of GNU GPL 2
6
7 from PyQt4.QtCore import *
8 from PyQt4.QtGui import *
9 from qgis.core import *
10 from qgis.gui import *
11 import sys
12 import os
13 # Import our GUI
14 from mainwindow_ui import Ui_MainWindow
15 
16 # Environment variable QGISHOME must be set to the 1.0 install directory
17 # before running this application
18 qgis_prefix = os.getenv("QGISHOME")
\end{verbatim}

Un po' di questo dovrebbe apparire familiare dal nostro plugin, specialmente le importazioni PyQt4 e
QGIS. Alcune cose specifiche da notare sono le importazioni del nostro GUI alla linea
14 e l'importazione nella libreria CORE alla linea 9.

La nostra applicazione necessita di sapere dove trovare l'istallazione di QGIS. Per questo, impostiamo l'ambiente variabile \usertext{QGISHOME} in modo che indichi la directory di istallazione di QGIS 1.x Alla linea 20 memorizziamo questo valore dall'mbiente per un uso successivo.

Poi è necessario creare la nostra classe \classname{MainWindow} che conterrà tutta la logica della nostra applicazione.
\begin{verbatim}
21 class MainWindow(QMainWindow, Ui_MainWindow):
22 
23   def __init__(self):
24     QMainWindow.__init__(self)
25 
26     # Required by Qt4 to initialize the UI
27     self.setupUi(self)
28 
29     # Set the title for the app
30     self.setWindowTitle("QGIS Demo App")
31 
32     # Create the map canvas
33     self.canvas = QgsMapCanvas()
34     # Set the background color to light blue something
35     self.canvas.setCanvasColor(QColor(200,200,255))
36     self.canvas.enableAntiAliasing(True)
37     self.canvas.useQImageToRender(False)
38     self.canvas.show()
39 
40     # Lay our widgets out in the main window using a 
41     # vertical box layout
42     self.layout = QVBoxLayout(self.frame)
43     self.layout.addWidget(self.canvas)
44 
45     # Create the actions for our tools and connect each to the appropriate
46     # method
47     self.actionAddLayer = QAction(QIcon("(qgis_prefix + "/share/qgis/themes/classic/mActionAddLayer.png"),
48     \
49         "Add Layer", self.frame)
50     self.connect(self.actionAddLayer, SIGNAL("activated()"), self.addLayer)
51     self.actionZoomIn = QAction(QIcon("(qgis_prefix + "/share/qgis/themes/classic/mActionZoomIn.png"), \
52         "Zoom In", self.frame)
53     self.connect(self.actionZoomIn, SIGNAL("activated()"), self.zoomIn)
54     self.actionZoomOut = QAction(QIcon("(qgis_prefix + "/share/qgis/themes/classic/mActionZoomOut.png"), \
55         "Zoom Out", self.frame)
56     self.connect(self.actionZoomOut, SIGNAL("activated()"), self.zoomOut)
57     self.actionPan = QAction(QIcon("(qgis_prefix + "/share/qgis/themes/classic/mActionPan.png"), \
58         "Pan", self.frame)
59     self.connect(self.actionPan, SIGNAL("activated()"), self.pan)
60     self.actionZoomFull = QAction(QIcon("(qgis_prefix + "/share/qgis/themes/classic/mActionZoomFullExtent.png"), \
61         "Zoom Full Extent", self.frame)
62     self.connect(self.actionZoomFull, SIGNAL("activated()"),
63     self.zoomFull)
64 
65     # Create a toolbar
66     self.toolbar = self.addToolBar("Map")
67     # Add the actions to the toolbar
68     self.toolbar.addAction(self.actionAddLayer)
69     self.toolbar.addAction(self.actionZoomIn)
70     self.toolbar.addAction(self.actionZoomOut);
71     self.toolbar.addAction(self.actionPan);
72     self.toolbar.addAction(self.actionZoomFull);
73 
74     # Create the map tools
75     self.toolPan = QgsMapToolPan(self.canvas)
76     self.toolZoomIn = QgsMapToolZoom(self.canvas, False) # false = in
77     self.toolZoomOut = QgsMapToolZoom(self.canvas, True) # true = out
\end{verbatim}

Le linee da 21 a 27 costituiscono la dichiarazione di base e l'inizializzazione della 
\classname{MainWindow} e le impostazioni dell'interfaccia utente usando il metodo 
\method{setupUi}. Questo è richiesto per tutte le applicazioni.

Quindi si imposta il titolo per l'applicazione così dice qualcosa di più interessante che \usertext{MainWindow} (linea 30). Una volta che questo è fatto, siamo pronti a completare l'interfaccia utente. Quando la si è creata in Designer, l'abbiamo lasciata abbozzata---solo una finestra principale e una cornice. Si può aver aggiunto un menu ed una barra degli strumenti usando Designer, comunque lo faremo con Python.

Nelle linee 33 fino a 38 si impostano il canvas della mappa, il colore di sfondo a celeste e si abilita la distorsione minima. Si specifica anche di non usare una \classname{QImage} per la rappresentazione grafica (fidatevi a questo riguardo) e poi si imposta il canvas a visibile chiamando il metodo \method{show}.

Quindi si imposta il layer affinchè usi uno schema a riquadro verticale all'interno della cornice e si aggiunge ad esso il canvas della mappa alla linea 43.

Le linee da 48 a 63 impostano le azioni e le connessioni per gli strumentinella nostra barra degli strumenti. Per ogni strumento, si crea una \classname{QAction} usando l'icona che abbiamo definito nel tema classico di QGIS. Poi colleghiamo il segnale \usertext{activated} dallo strumento al metodo nella nostra classe che gestirà l'azione. Questo è simile a come impostare le cose nell'esempio plugin.

Una volta che si hanno l'azione e la connessione, si deve aggiungerle alla barra degli strumenti.
Nelle linee da 66 a 72 si crea la barra degli strumenti e si aggiunge ad esse ogni strumento.

Infine si creano tre strumenti mappa per l'applicazione (linee da 75 a
77). Si useranno gli strumenti mappa in un momento dopo aver definito i metodi per rendere l'applicazione funzionale. Vediamo i metodi per gli strumenti mappa.

\begin{verbatim}
78   # Set the map tool to zoom in
79   def zoomIn(self):
80     self.canvas.setMapTool(self.toolZoomIn)
81 
82   # Set the map tool to zoom out
83   def zoomOut(self):
84     self.canvas.setMapTool(self.toolZoomOut)
85 
86   # Set the map tool to 
87   def pan(self):
88    self.canvas.setMapTool(self.toolPan)
89 
90   # Zoom to full extent of layer
91   def zoomFull(self):
92     self.canvas.zoomFullExtent()
\end{verbatim}

For each map tool, we need a method that corresponds to the connection we made
for each action. In lines 79 through 88 we set up a method for each of the
  three tools that interact with the map. When a tool is activated by clicking
  on it in the toolbar, the corresponding method is called that ``tells'' the
  map canvas it is the active tool. The active tool governs what happens when
  the mouse is clicked on the canvas.

The \usertext{zoom to full extent} tool isn't a map tool---it does its job
without requiring a click on the map. When it is activated, we call the
\method{zoomFullExtent} method of the map canvas (line 92).  This completes
the implementation of all our tools except one---the \usertext{Add Layer}
tool. %FIXME 
Let's look at it next:

\begin{verbatim}
93   # Add an OGR layer to the map
94   def addLayer(self):
95     file = QFileDialog.getOpenFileName(self, "Open Shapefile", ".", "Shapefiles
96     (*.shp)")
97     fileInfo = QFileInfo(file)
98 
99     # Add the layer
100     layer = QgsVectorLayer(file, fileInfo.fileName(), "ogr")
101
102    if not layer.isValid():
103      return
104
105    # Change the color of the layer to gray
106    symbols = layer.renderer().symbols()
107    symbol = symbols[0]
108    symbol.setFillColor(QColor.fromRgb(192,192,192))
109
110    # Add layer to the registry
111    QgsMapLayerRegistry.instance().addMapLayer(layer);
112
113    # Set extent to the extent of our layer
114    self.canvas.setExtent(layer.extent())
115
116    # Set up the map canvas layer set
117    cl = QgsMapCanvasLayer(layer)
118    layers = [cl]
119    self.canvas.setLayerSet(layers)
\end{verbatim}

In the \method{addLayer} method we use a \classname{QFileDialog} to get the
name of the shapefile to load. This is done in line 96.
Notice that we specify a ``filter'' so the dialog will only show files of
type \filename{.shp}.

Next in line 97 we create a \classname{QFileInfo} object from the shapefile
path.  Now the layer is ready to be created in line 100. Using the
\classname{QFileInfo} object to get the file name from the path we specify it 
for the name of the layer when it is created.  To make sure that the layer is 
valid and won't cause any problems when loading, we check it in line 102. If
it's bad, we bail out and don't add it to the map canvas.

Normally layers are added with a random color. Here we want to tweak the
colors for the layer to make a more pleasing display. Plus we know we are
going to add the \filename{world\_borders} layer to the map and this will make
it look nice on our blue background. To change the color, we need to get the
symbol used for rendering and use it to set a new fill color. This is done in
lines 106 through 108. 

All that's left is to actually add the layer to the registry and a few other
housekeeping items (lines 111 through 119). This stuff is standard for adding
a layer and the end result is the world borders on a light blue background.
The only thing you may not want to do is set the extent to the layer, if you
are going to be adding more than one layer in your application.

That's the heart of the application and completes the \classname{MainWindow} class. 

\subsection{Finishing Up}

The remainder of the code shown below creates the \object{QgsApplication}
object, sets the path to the QGIS install, sets up the \method{main} method
and then starts the application. The only other thing to note is that we move
the application window to the upper left of the display. We could get fancy
and use the Qt API to center it on the screen.

\begin{verbatim}
120 def main(argv):
121   # create Qt application
122   app = QApplication(argv)
123 
124   # Initialize qgis libraries
125   QgsApplication.setPrefixPath(qgis_prefix, True)
126   QgsApplication.initQgis()
127 
128   # create main window
129   wnd = MainWindow()
130   # Move the app window to upper left
131   wnd.move(100,100)
132   wnd.show()
133 
134   # run!
135   retval = app.exec_()
136   
137   # exit
138   QgsApplication.exitQgis()
139   sys.exit(retval)
140 
141 
142 if __name__ == "__main__":
143   main(sys.argv)
\end{verbatim}

\subsection{Running the Application}

Now we can run the application and see what happens. Of course if you are like 
most developers, you've been testing it out as you went along. 

Before we can run the application, we need to set some environment variables. 

\nix{}\osx{}
\begin{verbatim}
export LD_LIBRARY_PATH=$HOME/qgis/lib%$
export PYTHONPATH=$HOME/qgis/share/qgis/python
export QGISHOME=$HOME/qgis%$
\end{verbatim}

\win{}
\begin{verbatim}
set PATH=C:\qgis;%PATH%
set PYTHONPATH=C:\qgis\python
set QGISHOME=C:\qgis
\end{verbatim}

We assume
\begin{itemize}
\item\nix{}\osx{}QGIS is installed in 
your home directory in 
\filename{qgis}. 
\item\win{}QGIS is installed in \filename{C:\textbackslash qgis}.
\end{itemize}

When the application starts up, it looks like this:

%\begin{figure}[ht]
%\begin{center}
%  \caption{Starting the new demo application}\label{fig:demo_app_startup}%\smallskip
%  \includegraphics[scale=0.8]{getdsn}
%\end{center}
%\end{figure}

To add the \filename{world\_borders} layer, click on the 
\usertext{Add Layer} tool and navigate to the data directory.
Select the shapefile and click \button{Open} to add it to the map. 
Our custom fill color is applied and the result is:

%\begin{figure}[ht]
%\begin{center}
%  \caption{Adding a layer the demo application}\label{fig:demo_app_done}%\smallskip
%  \includegraphics[scale=0.8]{getdsn}
%\end{center}
%\end{figure}

Creating a PyQGIS application is really pretty simple.  In less than 150 lines
of code we have an application that can load a shapefile and navigate the map.
If you play around with the map, you'll notice that some of the built-in
features of the canvas also work, including mouse wheel scrolling and panning
by holding down the \keystroke{Space} bar and moving the mouse.

Some sophisticated applications have been created with PyQGIS and more are in 
the works. This is pretty impressive, considering that this development has 
taken place even before the official release of QGIS 1.0.

\begin{Tip}\caption{\textsc{Documentation For PyQGIS}}
\qgistip{Whether you are writing a plugin or a PyQGIS application, you are
going to need to refer to both the QGIS API documentation
(\url{http://doc.qgis.org}) and the PyQt Python Bindings Reference Guide
(\url{http://www.riverbankcomputing.com/Docs/PyQt4/pyqt4ref.html}). These
documents provide information about the classes and methods you'll use to
bring your Python creation to life.
}
\end{Tip} 
