\section{Crear aplicaciones}

Uno de los objetivos de QGIS es proporcionar no sólo una aplicación, sino un conjunto de
bibliotecas que se puedan usar para crear nuevas aplicaciones. Este objetivo se ha realizado
con la reconstrucción de bibliotecas que tuvo lugar después del lanzamiento de la versión 0.8.
Con el lanzamiento de la 0.9 es posible el desarrollo de aplicaciones independientes que usen
bien C++ o Python.

En este capítulo echaremos una breve ojeada al proceso de crear aplicaciones independientes en
Python. El blog de QGIS tiene varios ejemplos de creación de aplicaciones en
PyQGIS\footnote{An application created using Python and the QGIS bindings}. Usaremos uno de
ellos como punto de partida para tener una idea de cómo crear una aplicación.

Las funciones que queremos en la aplicación son:

\begin{itemize}
\item Cargar una capa vectorial.
\item Panorámica.
\item Acercar y alejar zum.
\item Zum a la extesión completa de la capa.
\item Estalecer colores personalizados al cargar la capa.
\end{itemize} 

Se trata de un conjunto mínimo de funciones. Comencemos por diseñar la GUI usando Qt Designer.

\subsection{Diseñar la GUI}

Puesto que estamos creando una aplicación mínima, usaremos la misma aproximación con la GUI. 
Usando Qt Designer, creamos una MainWindow sencilla sin menús ni barras de herramientas. 
Esto nos da un slate en blando con el que trabajar. Para crear la MainWindow:

\begin{enumerate}
\item Crear un directorio para desarrollar la aplicación y cambiar a él.
\item Ejecutar Qt Designer.
\item Deba aparecer el diálogo "Formulario nuevo". Si no lo hace, seleccionar 
\textsl{Formulario nuevo...} del menú \textsl{Archivo}.
\item Seleccionar "Ventana principal" de la lista de plantillas/formularios.
\item Pulsar \textsl{Crear}.
\item Redimensionar la nueva ventana a algo manejable.
\item Buscar el control Marco (Frame) en la lista (bajo Contenedores) y arrastrarlo a la ventana principal
que acabamos de crear.
\item Pulsar fuera del marco para seleccionar el área de la ventana principal.
\item Pulsar en la herramienta \textsl{Lay Out in a Grid}. Al hacerlo el marco se expandirá hasta
ocupar totalmente la ventana principal.
\item Guardar el formulario como \textsl{mainwindow.ui}.
\item Salir de Qt Designer.
\end{enumerate} 

Ahora compile el formulario usando el compilador de la interfaz de PyQt:

\begin{verbatim}
   pyuic4 -o mainwindow_ui.py mainwindow.ui
\end{verbatim}

Esto crea la fuente de Python para la ventana principal de la GUI. Lo siguiente que necesitamos es crear
el código de la aplicación para rellenar la slate en blanco con algunas herramientas que podamos usar.

\subsection{Crear la VentanaPrincipal}

Ahora estamos listos para escribir la clase \textbf{MainWindow} que hará el trabajo real. Puesto que
Since it takes up quite a few lines, we'll look at it in chunks, comenzaremos con la sección de
importación y la configuración del entorno:

\begin{verbatim}
1 # Loosely based on:
2 #   C++ Tutorial 2 oribignal por Tim Sutton
3 #   migrado a Python por Martin Dobias
4 #   con mejoras por Gary Sherman para FOSS4G2007
5 # Licenciado bajo los términos de la GNU GPL 2
6
7 from PyQt4.QtCore import *
8 from PyQt4.QtGui import *
9 from qgis.core import *
10 from qgis.gui import *
11 import sys
12 import os
13 # Importar nuestra GUI
14 from mainwindow_ui import Ui_MainWindow
15 # Importar nuestros recursos (iconos)
16 import resources
17 
18 # La variable de entorno QGISHOME se debe establecer al directorio de instalación de la versión 0.9
19 # antes de ejecutar esta aplicación
20 qgis_prefix = os.getenv("QGISHOME")
\end{verbatim}

Parte de esto debería resultar familiar de nuestro complemento, especialmente las importaciones de PyQt4 y
QGIS. Algunas cosas específicas que destacar son la importacion de nuestra GUI en la línea 14 y la
importación de nuestro archivo de recursos en la línea 16.

Nuestra aplicación necesita saber dóndo encontrar la instalación de QGIS. Por eso, establecemos la
variable de entorno QGISHOME para que apunto al directorio de instalación de QGIS 0.9. En la línea
20 guardamos este valor del entorno para usarla después.

Lo siguiente que necesitamos es crear nuestra clase \textbf{MainWindow} que contendrá toda la lógica de
nuestra aplicación.
\begin{verbatim}
21 class MainWindow(QMainWindow, Ui_MainWindow):
22 
23   def __init__(self):
24     QMainWindow.__init__(self)
25 
26     # Requerido por Qt4 para inicializar la UI
27     self.setupUi(self)
28 
29     # Establecer el título de la aplicación
30     self.setWindowTitle("FOSS4G2007 Demo App")
31 
32     # Crear el lienzo del mapa
33     self.canvas = QgsMapCanvas()
34     # Establecer el color de fondo a azul claro
35     self.canvas.setCanvasColor(QColor(200,200,255))
36     self.canvas.enableAntiAliasing(True)
37     self.canvas.useQImageToRender(False)
38     self.canvas.show()
39 
40     # Disponer nuestros controles en la ventana principal usando una 
41     # vertical box layout
42     self.layout = QVBoxLayout(self.frame)
43     self.layout.addWidget(self.canvas)
44 
45     # Crear las acciones para nuestras herramientas y conectar cada una con el método
46     # adecuado
47     self.actionAddLayer = QAction(QIcon(":/foss4g2007/mActionAddLayer.png"),
48     \
49         "Add Layer", self.frame)
50     self.connect(self.actionAddLayer, SIGNAL("activated()"), self.addLayer)
51     self.actionZoomIn = QAction(QIcon(":/foss4g2007/mActionZoomIn.png"), \
52         "Zoom In", self.frame)
53     self.connect(self.actionZoomIn, SIGNAL("activated()"), self.zoomIn)
54     self.actionZoomOut = QAction(QIcon(":/foss4g2007/mActionZoomOut.png"), \
55         "Zoom Out", self.frame)
56     self.connect(self.actionZoomOut, SIGNAL("activated()"), self.zoomOut)
57     self.actionPan = QAction(QIcon(":/foss4g2007/mActionPan.png"), \
58         "Pan", self.frame)
59     self.connect(self.actionPan, SIGNAL("activated()"), self.pan)
60     self.actionZoomFull = QAction(QIcon(":/foss4g2007/mActionZoomFullExtent.png"), \
61         "Zoom Full Extent", self.frame)
62     self.connect(self.actionZoomFull, SIGNAL("activated()"),
63     self.zoomFull)
64 
65     # Crear una barra de herramientas
66     self.toolbar = self.addToolBar("Map")
67     # Add the actions to the toolbar
68     self.toolbar.addAction(self.actionAddLayer)
69     self.toolbar.addAction(self.actionZoomIn)
70     self.toolbar.addAction(self.actionZoomOut);
71     self.toolbar.addAction(self.actionPan);
72     self.toolbar.addAction(self.actionZoomFull);
73 
74     # Crear las herramientas de mapa
75     self.toolPan = QgsMapToolPan(self.canvas)
76     self.toolZoomIn = QgsMapToolZoom(self.canvas, False) # false = in
77     self.toolZoomOut = QgsMapToolZoom(self.canvas, True) # true = out
\end{verbatim}

Las líneas 21 a 27 son la declaración básica y la inicialización de la \textbf{MainWindow}
y la configuración de la interfaz de usuario usando el método \textsl{setupUi}. Esto hace
falta para todas las aplicaciones.

A continuación ponemos el título de la aplicación de forma que diga algo más interesante que 'MainWindow' 
(línea 30). Una vez que esto está hecho, estamos listos para completar la interfaz de usuario. Cuando la 
creamos en el Designer, la dejamos muy escasa---sólo una ventana principal y un marcho. Se podría haber añadido 
un menú y la barra de herramientas usando el Designer, sin embargo lo haremos con Python.

En las líneas 33 a 38 configuramos la vista del mapa, establecemos el color de fondo a azul claro y habilitamos 
antialiasing. También le decimos que no use un QImage para renderizar (confiar en mi en esto) y hacemos visible 
el lienzo del mapa llamando al método \textsl{show}.

A continuación configuramos la capa para que use una disposición de caja vertical dentro del marco y le 
añadimos la vista del mapa en la línea 43.

Las líneas 48 a 63 configuran las acciones y conexiones de las herramientas de nuestra barra de herramientas. 
Para cada herramienta creamos una \textbf{QAction} usando el icono que definimos en nuestro archivo de recursos. 
Luego conectamos la señal \textsl{activated} de la herramienta al método de nuestra clase que manejará la acción. 
Esto es similar a cómo configuramos las cosas en el ejemplo de complemento.

Una vez que tenemos las acciones y las conexiones, necesitamos añadirlas a la barra de herramientas. En las 
líneas 66 a 72 creamos la barra de herramientas y le añadimos cada herramienta.

Por último creamos las tres herramientas de mapa para la aplicación (líneas 75 a 77). Usaremos las herramientas en 
un momento cuando definamos los métodos para hacer funcional la aplicación. Veamos los métodos para las herramientas de mapa.

\begin{verbatim}
78   # Establecer la herramienta de mapa para acercar zum
79   def zoomIn(self):
80     self.canvas.setMapTool(self.toolZoomIn)
81 
82   # Establecer la herramienta de mapa para alejar zum
83   def zoomOut(self):
84     self.canvas.setMapTool(self.toolZoomOut)
85 
86   # Establecer la herramienta de mapa para panorámica 
87   def pan(self):
88    self.canvas.setMapTool(self.toolPan)
89 
90   # Zum a la extensión de la capa
91   def zoomFull(self):
92     self.canvas.zoomFullExtent()
\end{verbatim}

Para cada herramienta de mapa necesitamos un método que corresponda a la conexión que hemos hecho para 
cada acción. En las líneas 79 a 88 establecemos el método para cada una de las tres herramientas que interaccionan 
con el mapa. Cuando se activa una herramienta pulsando en ella en la barra de herramientas, se llama al método 
correspondiente que ``le dice'' a la vista del mapa que esa es la herramienta activa, la cual gobierna lo que 
pasa cuando se pulsa el ratón sobre la vista del mapa.

La herramienta zum a toda la extensión no es una herramienta de mapa---hace su trabajo sin que se requiera una 
pulsación en el mapa. Cuando se activa llamamos al método \textsl{zoomFullExtent} de la vista del mapa (línea 92). 
Esto completa la implementación de todas nuestras herramientas menos una---la herramienta añadir capa. Veámosla a continuación:

\begin{verbatim}
93   # Añadir una capa OGR al mapa
94   def addLayer(self):
95     file = QFileDialog.getOpenFileName(self, "Abrir archivo Shape", ".", "Shapefiles
96     (*.shp)")
97     fileInfo = QFileInfo(file)
98 
99     # Añadir la capa
100     layer = QgsVectorLayer(file, fileInfo.fileName(), "ogr")
101
102    if not layer.isValid():
103      return
104
105    # Cambiar el color de la capa a gris
106    symbols = layer.renderer().symbols()
107    symbol = symbols[0]
108    symbol.setFillColor(QColor.fromRgb(192,192,192))
109
110    # Añadir capa al registro
111    QgsMapLayerRegistry.instance().addMapLayer(layer);
112
113    # Establecer extensión a la de nuestra capa
114    self.canvas.setExtent(layer.extent())
115
116    # Establecer el conjunto de capas de la vista del mapa
117    cl = QgsMapCanvasLayer(layer)
118    layers = [cl]
119    self.canvas.setLayerSet(layers)
\end{verbatim}

En el método \textsl{addLayer} usamos \textbf{QFileDialog} para obtener el nombre del archivo shape a cargar. 
Esto se hace en la línea 96. Observe que especificamos un ``filtro'' para que el diálogo sólo muestre los archivos 
de tipo \textsl{.shp}.

Next in line 97 we create a \textbf{QFileInfo} object from the shapefile path. Now the layer is
ready to be created in line 100. Using the \textbf{QFileInfo} object to get the file name
from the path we specify it for the name of the layer when it is created. To make sure that the layer is valid and won't
cause any problems when loading, we check it in line 102. If it's bad, we bail out and don't add it to
the map canvas.

Normally layers are added with a random color. Here we want to tweak the colors for the layer to make a more pleasing
display. Plus we know we are going to add the \textsl{world\_borders} layer to the map and this will make it look nice
on our blue background. To change the color, we need to get the symbol used for rendering and use it to set a new fill color. This is done in lines
106 through 108. 

All that's left is to actually add the layer to the registry and a few other housekeeping items (lines
111 through 119). This stuff is standard for adding a layer and the
end result is the world borders on a light blue background. The only thing you may not want to do is set the extent to
the layer, if you are going to be adding more than one layer in your application.

That's the heart of the application and completes the \textbf{MainWindow} class. 

\subsection{Finishing Up}

The remainder of the code shown below 
creates the \textbf{QgsApplication} object, sets the path to the QGIS install, sets
up the \textsl{main} method and then starts the application. The only other thing to note is that we move the
application window to the upper left of the display. We could get fancy and use the Qt API to center it on the screen.

\begin{verbatim}
120 def main(argv):
121   # create Qt application
122   app = QApplication(argv)
123 
124   # Initialize qgis libraries
125   QgsApplication.setPrefixPath(qgis_prefix, True)
126   QgsApplication.initQgis()
127 
128   # create main window
129   wnd = MainWindow()
130   # Move the app window to upper left
131   wnd.move(100,100)
132   wnd.show()
133 
134   # run!
135   retval = app.exec_()
136   
137   # exit
138   QgsApplication.exitQgis()
139   sys.exit(retval)
140 
141 
142 if __name__ == "__main__":
143   main(sys.argv)
\end{verbatim}

\subsection{Running the Application}

Now we can run the application and see what happens. Of course if you are like most developers, you've been testing it
out as you went along. 

Before we can run the application, we need to set some environment variables. On Linux or OS X:

\begin{verbatim}
export LD_LIBRARY_PATH=$HOME/qgis_09/lib
export PYTHONPATH=$HOME/qgis_09/share/qgis/python
export QGISHOME=$HOME/qgis_09
\end{verbatim}

For Windows:
\begin{verbatim}
set PATH=C:\qgis;%PATH%
set PYTHONPATH=C:\qgis\python
set QGISHOME=C:\qgis
\end{verbatim}

In the case of Linux or OS X, we assume that QGIS is installed in your home directory in 
\textsl{qgis\_09}. For Windows, QGIS is installed in \textsl{C:\textbackslash qgis}.

When the application starts up, it looks like this:

\begin{figure}[ht]
\begin{center}
  \caption{Starting the new demo application}\label{fig:demo_app_startup}\smallskip
  \includegraphics[scale=0.8]{getdsn}
\end{center}
\end{figure}

To add the \textsl{world\_borders} layer, click on the \textsl{Add Layer} tool and navigate to the data directory.
Select the shapefile and click \textsl{Open} to add it to the map. Our custom fill color is applied and the result is:

\begin{figure}[ht]
\begin{center}
  \caption{Adding a layer the demo application}\label{fig:demo_app_done}\smallskip
  \includegraphics[scale=0.8]{getdsn}
\end{center}
\end{figure}

Creating a PyQGIS application is really pretty simple. In less than 150 lines of code we have an application that can
load a shapefile and navigate the map. If you play around with the map, you'll notice that some of the built-in features
of the canvas also work, including mouse wheel scrolling and panning by holding down the \textsl{Space} bar and
moving the mouse.

Some sophisticated applications have been created with PyQGIS and more are in the works. This is pretty impressive,
considering that this development has taken place even before the official release of QGIS 0.9.

\begin{Tip}\caption{\textsc{Documentation For PyQGIS}}
\qgistip{Whether you are writing a plugin or a PyQGIS application, you are going to
need to refer to both the QGIS API documentation (\url{http://qgis.org}) and
the PyQt Python Bindings Reference Guide
(\url{http://www.riverbankcomputing.com/Docs/PyQt4/pyqt4ref.html}). These
documents provide information about the classes and methods you'll
use to bring your Python creation to life.
}
\end{Tip} 